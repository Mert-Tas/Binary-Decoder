
# Atrisense 360 Lidar Binary Decoder

This repository contains a production-ready Python implementation for decoding and visualizing binary data generated by the fictional **Atrisense 360 lidar sensor**.

The solution:
- Decodes raw binary records into structured data
- Converts spherical coordinates to Cartesian (x, y, z)
- Exports the result as a standard **PLY point cloud**
- Visualizes the point cloud using **matplotlib**

---

## Data Format

Each record in the binary file is decoded using the following C++ structure:

```cpp
struct AtrisenseRecord {
    uint32_t scan_number;
    float    x_angle_deg;
    float    y_angle_deg;
    float    distance_m;
    uint16_t intensity;
};

- Binary encoding: little-endian
- Record size: 18 bytes
- Input file contains 33,576 records

---

## Coordinate Conversion

Each record is converted from spherical to Cartesian coordinates using the conversion formula:
	x = d · cos(y) · cos(x)
	y = d · cos(y) · sin(x)
	z = d · sin(y)

Angles are converted from degrees to radians before conversion.

---

## Requirements

pip install -r requirements.txt

Required libraries:
- Python 3.9+
- numpy
- matplotlib

---

## How to run

1. Place the binary file "atrisense.bin" next to the script.
2. Run the decoder
	python BinaryDecoder.py

This will:
- Decode all records
- Convert them to Cartesian coordinates
- Export a PLY file:
	atrisense_pointcloud.ply
- Display a 3D visualization using matplotlib

---

## Visualization Preview

Below is a preview of the decoded Atrisense 360 LiDAR point cloud rendered using matplotlib:

![Decoded Point Cloud](decoded_image.png)

---

## Output

- atrisense_pointcloud.ply — Point cloud in standard PLY format
- decoded_image.png — Screenshot of the 3D visualization

---

# Notes

- Basic input validation is applied (invalid distances are skipped)
- The solution is structured for readability and testability


## Validation

The correctness of the coordinate conversion was verified by

- Visualization of the resulting point cloud in 3D with matplotlib

- Numerical validation by reconstructing the distance from the Cartesian coordinates 
and comparing it with the original measured distance using a tolerance-based check to 
account for floating-point precision.

- A tolerance-based numerical validation step is included to verify the Cartesian conversion 
against the original sensor distances.


## Author

Mert Taş
Software Developer
mert.tas@gmail.com
---